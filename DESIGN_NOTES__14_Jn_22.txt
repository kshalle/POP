
Working on getting visual of a POP syntax graph

-] Have Famo.us, which has hierarchical drawning structure that fits well to what had in mind for POP

-] Famo.us has animations and physics engine, so as user modifies things, they can fly around in pleasing ways.

-] Famo.us structure is almost one-to-one with the visualizer's internal structure that I was imagining..  seems wasteful to duplicate..

-] However..  need the visualization to be independent of any particular drawing facility..  for example, the visualization should be reusable with a Java based canvas that is painted via Swing, as well as via Famo.us and via C++ drawing code..

-] The visualization must be specific to the data format..  therefore, it should be part of the holder that the data is inside of.  Don't want case where new syntax is added, and have to go around to all the different places, like Java app, and javascript displayer, and so on, and change code in all those! (even if they all take a plugin, that plugin will have to be in terms of the language -- java, javascript, C++, whatever -- and the plugin will have to spit out some standard thing anyway!)  
Rather, want the visualizer to be written once, in POP, and plugged into the data-holder.  It spits out standardized visual elements..  any technology can then take those visual elements and paint them to a screen.
The visualizer has fingers directly on the raw data, in whatever the internal format is for the holder..  A holder can have a different internal format vs external format..

(update: fighting with text -- haven't found any general way of calculating the width of text, given the font..  entry after entry from google search has variations on applying the text to a canvas, causing it to render, then getting the bounding box that was generated during render..  there doesn't seem to be, even for SVG, any way to predict the bounding box!!!?!?!?!  So.. there is a cascade effect..  the text must be contained within something, like a rectangle or elipse or whatever..  and, as worked out during the rest of this design session, the visualizer is responsible for calculating the placement of all the SVG shapes..  then the visualizer MUST know the size of the text, in order to know the size of the shape, in order to calculate a reasonable placement of shapes..  
   it is tempting to leave all the shape placements specified as relative, and let the final values be figured out inside the Display..  this would also allow things like employing the Famous physics engine to calculate placements, even let the placements evolve by themselves (like the D3 examples with the graph nodes flying around to find their own placement).. that would happen without the visualizer setting the placements..  rather, the visualizer would establish the visual "connectivity".. noooo..  that D3 thing relied upon knowing that it was a graph and that arcs acted like springs and nodes acted like weights, and nodes exerted n-body attraction..  but that is all specific to graphs..  would it generalize to arbitrary syntax?  Hmmmm..  if had an "atomic" level, where inside an atomic unit nothing moves relative,  then, yes, can treat the connections between these atomic things as springs, and each atomic thing has attractive mass and inertia..  can let them run around and find a stable configuration..
   Okay, so two issues: what about connections that go off-screen to out-side-the-view portions of syntax graph, and what about the user wanting to pin particular things in particular places..  often what a feeling of solidity, reliable placement so you know where everything is..
   Right, so this: for now, visualizer calculates fixed positions, but have in back of mind keeping ability for multiple kinds of visualizer within the same srcHolder..  and visualizer has ability to expect things of the Display, such as providing physics, and visualizer can maybe ask Display what kinds of visualization list it understands..  so then can add, say, dynamic view hierarchy, where visualizer specifies things like masses and springs and lets Display move them around as it sees fit..  can evolve standard view lists over time..  the Commander will have to include some facility for not allowing a user to select a visualizer that is unable to generate any of the list types acceptable to the Display the user is interacting with.)

-] A holder may also have other data-format-and-semantics specific things, such as a querier -- the querier defines the format of queries it accepts, and those queries are tailored to the nature of the data in the holder.  Hence, say, a video holder might have a querier plugged in that accepts canonical shapes, and then searches the raw video data for frames that contain that shape.  The querier would spit out things in a format that it defines.  For example, it may have a data structure for a video frame, and spit out a stream of frames that contain the requested shape.

-] Data formats should be visually defined.. for example, I should be able to draw a picture of a graph node, and that picture is the code that defines the data structure, which can then be used in other places in the code.  For example, in the Hamiltonian Path code, could have included a picture of a graph node, and connected a line to the portion being accessed, say, in a test, or in the "for all" construct..

-] Seeing a hierarchy of holders..  so a higher level holder could have multiple lower level holders inside of it..  getting a bit awkward, say with combining queriers and visualizers -- how do you combine visualizations from siblings?  there's something fundamental here.. 

-] No data may be warehoused outside a holder..  the holder collects the things needed to interact with the data, such as modifier, visualizer, querier, and not sure yet what all else..

-] Data outside a holder must be in the form of a data structure instance, where the structure was defined by the holder the data came from.  The holder took whatever internal format the data resided in and placed it into the data structure form.  All data within a POP system that is not inside a holder must be in the format of a structure defined using POP primitives.  NO RAW BYTES!  Bit twidling only upon bit-vector structures.  An adaptor is necessary in order to get a more primitive format of data (IE, can always do conditional tests on bits held in a bit-vector format, and build up values within a higher level format structure based on the test results.. example, do the math to accumulate individual bit values from a bit-vector, but accumulate them into an integer format.  Or, can test bits that represent graph edges, and build up a graph data structure.  aso..)

-] A visualizer can include animations as visual elements that it spits out.

-] Famous will generate events that are gestures such as mouse clicks.  The event handler will use the event data to connect the event to one of the original visual elements that was visualized.  It will construct a structure that states the visual element and the gesture details, and send that to the commander.

-] the commander will convert the visual element plus gesture into some action, such as moving the insertion point, or zooming the view, or adding a syntax node..  the command sends the command to the appropriate place -- could be the drawing engine (for zoom or pan actions).. or could be the modifier for insertion point or syntax element actions..  or could be some entity that carries out the action. For example when viewing a worksheet, a gesture could trigger re-calculation, so the action would be a "perform calculation" sent to one or more processors that are connected to the worksheet.

-] The modifier has access to the holder's internal data format, and can manipulate it directly.  It receives commands, such as generated by gestures performed on the display.  

-] A worksheet lives inside a holder as well..  the worksheet can talk to processors..  for example, the visualizer may simply include a reference to a processor that spits out data, and sends the reference in the visual element.  An image may be a good example..  the image is on the worksheet for some reason..  the visualizer embeds reference to image in an element and sends that to the display.  The display then directly gets the image data and paints it.

-] Right, so one way to combine visualizers in a hierarchy, is for higher level visualizers to specify a lower-level one that is to fill in the internals of a given bounding box.  So the lower-level is sent the bounding box, and it generates a view hierarchy that fits inside of that.  Not sure whether the Display should be the one that sends the requests and integrates the various responses, or the Visualizer should send the requests and integrate the responses.


==============================================
=         Display   Design  
=
==============================================
So, question..  what do display list elements look like?  Does visualizer produce the layout, for example, specify a bounding box and position for each element, including text, lines, etc?  Does it produce the bezier curves in SVG that connect syntax graph elements?

Or, does it send something with fewer details?  Let the Display calculate exact placement of visual elements?

What about pan and zoom?  Does Visualizer handle that, or Display..  pan means moving some elements out of the painted canvas and moving others in..  zoom does too, in addition to calculating new transforms for each element painted..  So, if Display does this, then it must either have all the visual elements in it, or else it much send a request to Visualizer that triggers sending what's needed..

Soooo..  make a two-way path between Display and Visualizer, in order to handle pan, zoom, 3D rotates, and so forth?

Orrrr..  leave that to the MVDM loop..  the pan/zoom/rotate gestures go into the command-maker, and thence into the visualizer, which then sends view update..

sooo..  this view update stuff..  does Display keep a full representation of the visual elements, and then translate that into Famo.us elements?  Or, does it keep, say, a current visualizer list..  where visualizer updates simply modify the previous list sent..  then Display translates the updated list into Famo.us elements..  given that Famo.us doesn't support removing render tree elements, that might be a good approach..  and it simplifies the thing about how to figure out what a visualizer update is and what to do with it inside the Display.

Okay.. now..  just need to figure out what the Visualizer actually sends..  how much detail..

You know what?  I don't want to think about it!  Just going to do something, see what happens, and then can modify later..  probably will never get modified, these choices have a way of sticking, due to momentum of volume of work and low improvement in changing..  but, don't want to stall myself, need to keep moving..

sooooo...  something has to calculate placement of bounding boxes, and calculate translations and sizing..  and move things in and out based on zoom, pan, rotate..  and trigger redraws and resends of display data for graphs and calculation results..  seems like if put placement and transform calcs inside Display then are making the Display an active thing, giving it intelligence and control..  then, run into problems when have a view that is composed of pieces from many different holders and different processors..  for example, displaying a worksheet, where the worksheet itself is in a holder that generates a view, and locations on the worksheet are calculated by live processors, and locations are graphs which are generated by graphing processors that take calculations from other processors..  want the worksheet holder to handle generating the view, and collecting the data from the other processors..  don't want the Display to have any kind of intelligence related to this!  

Hmmm..  so, if the worksheet holder is doing all of the collecting of data and triggering re-calcs, and melding together into a view..  then Display is simply passively painting that and collecting gestures that it sends back..  the holder then knows what to do with the gestures performed upon view elements..  

So that means that the Display should not be calculating pan and zoom and rotate!!  Those are responses to gestures, and those trigger behaviors from the visualizer (which may, in turn, have to trigger behaviors from other processors in order to get updated calcs to put into the view)

Got it, so as tempting as it is to peel off such gestures in the Display and build intelligence into there..  it will cause problems..  so best to have all the visual related processing be done inside the visualizers..  

so..  means the visualizer should send out things pretty close to renderable..

Now.  The question comes up..  what format?  Does the visualizer send out SVG?  Is that universal enough?  Will that cause problems with non-browser based approaches?  If not SVG, then what?  Will need to represent paths..  does visualizer calculate Bezier curves and send those?  Or does it just say "here are end points, connect these with a smooth path"?  Does the visualizer calculate how to route arcs within a graph around the other nodes in an optimal way?  If the user supplies helpers by moving things, does the Display remember that, or the Visualizer?  

Ahhhh..  okay..  if want the user to be able to affect the visual arrangement, then need to remember the gestures they give that are related to visual arrangement..  for example, they grab bezier control points and move them, in order to affect a curve, or add new points within a path in order to route it..  those things have to be remembered!  The Display has no place to store such things!!

Right..  that means that the holder must store info related to viewing the holder contents!  sooooo..  the visualizer must be the thing that generates any details that a person may want to adjust.

Right.  Any visual arrangement that a person might want to adjust must be stored inside the holder, and so the visualizer must be the thing that generates that level of detail.  Right.  Got it.



//========================  Visualizer Conclusions  ======================
//
//
//========================================================================
So.  Yes.  That means that the visualizer must send out bounding boxes, translations, sizing, path points, control points, and so forth.  So.  Yes.  SVG is looking like a good way to go..  has to be something!  Can invent my own equivalent, which specifies paths, shapes, widths, and so forth..  but what is the gain?  The only potential is sending in binary, to save the overhead of SVG's text embodiment.  The savings worth the effort?  NO!

Okay then.  SVG.  That is the visualizer's format for POP.  Or perhaps it just sends the values that go into the SVG?  The Display does the final conversion to text-based SVG format?  Hmmmm, what about custom syntax, which is SVG from the programmer?  Just send indication of SVG elements, together with the values?  Maybe enums for the SVG indicators, or something..

Now.  Question is, how much effort?  Is it more effort to send a representation, then construct text-repr inside Display?  Or more effort to construct SVG text in visualizer and send it ready-made?

Seems easier to just construct SVG text inside visualizer and send that.. 

Heck, if send representation, then are already forcing SVG!  It doesn't constrain the Display if send the text form..  the display is just as free to convert the binary form to something else as it is to convert the text form to something else..  so if Display is not browser, and doesn't have SVG drawing primitives, it has to do the extra step of parsing SVG in order to extract the values from the text, and then generate whatever internal form it has, such as calculating paths or even pixels itself..  the extraction from text does not seem like a terribly large burden compared to the rest.

Buuuut..  don't really care!  Going to generate text form inside visualizer, because, why not?  Then the Display only translates displayList elements into its internal thing that paints.  In the case of browser, Display translates display list into famo.us elements, placing the SVG verbatim onto famous surfaces, and makes the famous surface size the same as the SVG bounding box.

In fact, display list is going to represent almost verbatim what a Famo.us render tree will look like!  It is a fairly universal declaration..  hierarchy of local visual contexts, with relationship among those contexts, including relative placement in 3D space and relative sizing from one to another.

Alright, getting to it now..  display list will be a serialization of a hierarchy..  The top of the hierarchy is the view painted onto.  The Display tells the visualizer what the pixel dimensions are of the view.  The visualizer makes that the top level bounding box.  It then inserts bounding boxes within that, and inserts bounding boxes within those, and so forth down.  Each bounding box is either a hierarchy element, relationship element, or a painted element.  Hierarchy elements simply state what elements are included, and give their own bounding box.  Relationship elements are attached by the parent hierarchy element.  For example, it is the job of the parent to make sure all the children fit inside its bounding box.  The bounding box may be 2D or 3D.  A parent ensures the fit by attaching relationships to the children elements.  The relationships can be translations or scalings or rotations.. or actually any arbitrary 3D transform.  A hierarchy element knows nothing of the context in which it fits, so it has no way of attaching relationships to itself!  Each hierarchy element is responsible for ensuring that all descendants fit within its bounding box.  Any relationship attached to a hierarchy element is transitively applied to all descendants of the hierarchy element.  For example, if one is rotated in 3D, then it, together with all its contents, is rotated as a unit.  Each descendant maintains the same relationship to its parent as before..  but the entire bundle has been rotated as a unit!

Great..  so that is the display list..  it is a serialization of that hierarchy.  A display update then assumes a given hierarchy, and says "change this relationship between this parent and this child" or "remove this parent and all descendants" etc..  in effect, it specifies a change to the hierarchical structure..

Sooooo..  means that have two copies of the view hierarchy..  one inside the visualizer, which is serialized, and another inside the Display, which is translated into Display-local elements that are then painted.

Not the most efficient..  hurts me..  but, well, what are you going to do?  What's better?  Need the flexibility of having the visualizer control all changes to the view hierarchy.. and need the visualizer to calculate all placement and path details so that user changes can be remembered inside the holder (without something clunky like "save this view modification info as a black box and hand it to the Display, which knows what it means" yuck, just begging for loss of sync when move from one Display to another or even upgrade the Display!)..  

so, then, there's no way around having the visualizer internally represent the bounding box hierarchy as it constructs the details.  Thennnnn..  something must translate that representation into the internal Display representation!  The Display could have any native form internally..  canvas with paths drawn upon it, Java 2D, even just pixels, with all the code in between..  well, in effect, every Display ends up being everything between that hierarchy and on down to pixels!!

So, could just hand the data structure from visualizer to the Display..?  This is fine if both are inside same hardware, sharing memory..  but need a serialization if Display has separate memory..  which it will if the src holder is on a server and the display is a browser on a client!

Hmmm..  what about just handing the data structure to the Display for now..  can always add the serialization later, it's not functional!  :-)  Ahhh, yes.. less work.  Good.  Okay, will do that.  save serialization for later.  For now, in javascript, will build a src holder that saves syntax graph natively in JSON, as an internal data structure of the form made for GabePatterns.  The visualizer in the src holder will generate a view hierarchy from that data structure.  It will save any view related data within the syntax graph data structure as extra properties added to the nodes.  The visualizer will then hand a reference to the view hierarchy directly to the display object.  The display object will then generate famous elements from the view hierarcy elements.  View updates will simply be the visualizer changing the view hierarchy then calling the display with a reference to the changed hierarchy.

Done.  Make it so.

BTW, thinking to introduce another component, which is a helper for developers making custom syntax, that maybe takes some higher level view form and generates the view hierarchy from that..  this will act as a library for them, essentially..  (and, of course, there will be a serializer that turns a view hierarchy into a stream of visual objects sent to the Display, which will reconstruct the view hierarchy then translate that into elements that it paints.. for now, that serializer is just JSON!  It has provision to translate javascript objects into text form, and then on the other side parse that text form to reproduce the javascript objects.. might need extra logic in order to recreate the links among parents and children.. not sure whether JSON can go deep that way..).

//======================================================
//					Code Reuse
//
//======================================================

Actually, there are multiple kinds of code re-use:
-] in-line code, where have something that assumes a context (such as variables in the scope), and grabs what matches within that context and inserts that into the respective places inside its body.  For example, a macro does this, so do in-line functions.
-] processors that are communicated with.  Many function calls are this -- other places in the code are other processors, that send parameters to the function, and receive back a return response.
-] inheritance, where have a namespace hierarchy that is searched.. the context can be assigned to a variable, then a function name can be looked up within it (assigning an object to a variable equals assigning a namespace to a variable).  If the function name isn't found in the immediate context, then the parent(s) of that context is(are) searched, until the name is found.  So, code is re-used by making it accessible from a parent name-space.

In POP, in-line code has four forms:
-] meta-agents inside the syntax-graph/MVDM-loop, which contain code that is used as part of generating code that is inserted into the syntax graph.  For example, active syntax generates code at the point that the user gives the gesture to add it to the syntax graph.
-] selecting a hierarchy unit to be deep-copied to the current hole in the syntax graph (the syntax-graph of the original is duplicated)
-] selecting a hierarchy unit to be reference-inserted into the hole (the syntax graph of the original is hooked to, not duplicated)
-] macros -- in POP these are both meta-agents and also deep copies.  The macro selects things from the code surrounding where it is placed, and sucks those inside itself, and puts in a copy thus modified, into the syntax graph.

In POP, processor-communicated-with code has at least two forms:
-] connecting the inputs and outputs of one code-processor to another (this can be implied, for example on a worksheet, or direct, using the MVDM loop while in System (OS) view)
-] when sending a context to a processor-box, it creates a new processor to handle the incoming context.  That is equivalent to copies of the code at runtime, talking to each other -- the creation as well as the contents is communication..  but it's not like other forms, where inputs are connected to outputs!

In POP, inheritance can be accomplished via the copy-by-reference mechanism, or via the send-a-namespace/context mechanism (simply insert the variable connected to the processor that you want to receive sent data.. same variable name in each context, connected to different processors == polymorphism..  and the parent context attached, that has functions attached to names in it == inheritance)

In effect, POP has functional, object oriented, procedural, and declarative styles that can be done within it.  At least, the underlying mechanisms that set those things apart are all available within POP.

==============================================================
==
==       Editor and Gesture and Commander and Modifier
==
==============================================================

In famo.us, seeing putting up a rectangle that is placed in front of the others, and always in the plane of the camera, as the "menu"..

always have a set of mappings to the keys -- these mappings are set by the commander inside the srcHolder -- they are specific to the kind of data being visualized.  In the case of code, for the moment, only visualizing the code in the form of a syntax graph (will do the custom syntax visualizer next -- it will have challenges don't want to get into just yet -- need a way to create syntax graphs and turn Gabe loose on search and match to patterns, so minimum path to that).

So, seeing moving cursor around, and when hit a key, say the 'e' key, the port closest to the cursor will sprout an arrow that ends at the cursor..  the cursor is then moved to the target port and hitting e again locks onto there.. or perhaps just a left click, or perhaps space bar, etc..  choose in practice the one that feels most intuitive and convenient.

When cursor is over empty background, hit a key, say the 'a' key, and that creates a new empty element box..  s creates a new empty properties box..  space bar brings up the menu that shows the key mappings.. or maybe ctl-space..

another key zooms in on the elem or property box under the cursor

inside the box, can hit a key to move cursor between fields -- at each field, can use space to pop up another menu and the un-pop it..  which has the starting sequences of the valid entries for the field (IE, a list of the elem types -- might itself be a hierarchical menu -- pick one of the keys or sequences from this menu, then that pops up another menu that has its own sequences or keys..  eventually a leaf is a value placed into that field) --  or the menu entry describes the format of what can be typed into the field (Ex, variable name format)

===========
Soooo..  to make this work..
===========

Each bounding box in famous has an event handler on it..  want the first enclosing bounding box to receive the event.  The bounding boxes must have parent links so that can navigate out to the boxes that enclose the target box.

the event handler is fixed and generic to the Display..  however, the gestures understood are in an array that is given to the Display by the Commander.  When Display receives the "connect", it in turn sends a connect back to the Holder.  This asks for the Commander to be given to the Display.  It then tells the commander to give its gesture-handler pairs.

In javascript, the "gesture-handler pairs" is an object that has a field for each gesture it understands, and the value of that field is the function that does the computation related to the gesture.  The function receives the event object, plus the smallest enclosing bounding box.

The gesture-handler then turns the event plus bounding box into a command.  For example, if previously a gesture caused the start of the mode for typing text into a field -- say for entering the name of a variable -- then the gesture handler looks that up, within state enclosed with the gesture handler but shareable among different handlers.  The code then branches to where it extracts the key value from the event object.  It reuses a "key into field" command object, and packs it with data.  The data includes the model-object that is attached to the appropriate bounding box (the handler does the work of figuring out which bounding box corresponds to the syntax graph object that owns the field that is being typed into).  So, each bounding box has a back-link to the Model object that the shape inside the bounding box represents, where appropriate (IE, the bounding box for text has no back-link, but the bounding box for the element-box shape does have a back-link to the element object!)  Might make it just "useful info" -- for example, a text bounding box might include the name of the field of the object that the larger enclosing bounding box back-links to.  The gesture-handler will also extract any needed info from the event object, such as which key was pressed, and add that to the command-object.

The command is then sent to the Modifier, which changes the back-linked-to syntax graph objects.  As part of that, it also modifies the visualized-sub-graph, and notifies the visualizer to update.

=====================================
Okay, have a view-tree cross-linked to the basic syntax graph..  and it's working, being painted by the Display.

Now, need to get a JSON dump of the syntax graph, store that on disk, and then get it back in, as objects in javascript.

So, JSON does stringify for dumping, and parse from bringing it back in, and they even allow overrides and "translate/restore" functions for difficult values..

The one issue is that they don't handle circular data structures, and the syntax graph has to be circular..  because a gesture can land anywhere in it, so have to be able to start at any point and navigate outward..  so ports have to be bi-directionally linked to each other, which is a circle.

Now..  how to deal with that..  what approach to traverse the syntax graph, parse the pieces out as JSON, and then to reverse that..?

I'm thinking just do a standard spanning tree algorithm, and turn all port links into IDs..  When push out.. overwrite, then do JSON stringify, then replace the links..  (means need exclusive access -- can't be sharing with others..)

==
So, the steps:
-] start at root, get first element..
-] it will have properties attached..
-] it will have an array of ports in and array of ports out
- -] these ports will have pointers back to the element.. those must be replaced with ID before stringify
-] it will have array of linked elements..  those can potentially link back around in a circle..  replace those links with IDs before stringify
-] visit each port
- -] each may have pointers to paired ports..  replace these with IDs

after that, can safely stringify the element, which will catch all the ports, and all the element properties and all the port properties

Then, find the next element to visit..  do that by:
-] visit all linkedElems
-] visit all ports, and for each port, visit all paired ports, and for each of those, visit the linked elem.
-] before visit an elem, save position are in -- on stack or in struct
-] When visit elem, check whether marked as already visited.  If yes, restore position saved, if not, process as above.
-] when all reachable neighbors of elem done, restore position saved before visiting elem.  If none, then are done.

==
Now, have view boxes attached to the elements (there is a tree of viewboxes for each element, which includes boxes for the ports ((which only provide scaling and translation of the sub-graph that appears inside the port)) and any visual cues caused by properties or derived from properties)

disconnect the ones for this elem from the ones for other elems..  so a given box can only be reached from exactly one elem!

Soooo..  what need is to have two separate kinds of hierarchy..  there is hierarchy for a single element node, which includes all of the things that are visualized for that element, including boxes for empty ports, and indicators of the boundary around what should be drawn inside the POSITION of a given port.  Call that an view-set.

Then there is hierarchy between different view-sets..  for example, which other element goes inside a given port's boundary box.. this is what applies parental shift and scale transforms.
   So there are some cases here..  element inside port of another element, and element that is a linked element of another.  Also case of ordered children of a common parent.
   For example, in the Gabe Transform rule, the top level element is a hierarchy element.  It has a big blue arrow drawn between the query pattern sub-graph and the resultant pattern sub-graph..  the tail goes to the parent's first child, the tip to the second child, and the two children are arranged side-by-side inside of the bounding box of the parent..  where the parent has no shape to represent it directly, but rather a positioning of children rule and the blue arrow between children.
   Hence, that top level element has, as it's view set, a view box that has the blue arrow as its shape, and has two transforms, one to be applied to each child that puts the child in place and scales it.
   
So, it is up to the parent to decide position of each child hierarchy..  has to know the contents of the child hierarchies in order to calc the size of bounding box..  but, will deal with sizing later..  rely upon user interaction to get the sizing right..  do sizing as graph grows, one bit at a time..  for now, the parent has a translation and scale to apply to the child, while the child has its own declared size..  so, that is view-set to view-set

So, each view-set has rules about how to arrange things inside the set..  and another set of rules about how to arrange children or neighbor sets!

So, the visualizer is the thing that knows the rules and calculates placement and size (scale)..  this results in artefacts: links between boxes and links between sets, and info on translate and scale!

so within a set there is no scaling.

between sets, either of them can state itself as reference for the pair, and then state a translation and scaling for the other.  It is an error for two directly linked to both state themselves the reference for the other.  However, a given set can act in one case as a reference and in another as a recipient, across different sets that are paired to it.

So, it is the link from one view-set to another where the reference designation lies, along with the translation and scaling of the recipient

Hmmmmmm..  means that a link between two viewbox-sets is a full object rather than just a pointer!

Hmmmmmm..  want to specialize to the point that encode this distinction about view-set versus simple viewbox?  What about making it a view-set box..  leaving out any notion of element?  Then it just says that view boxes can be grouped into sets that are treated as a single whole, as far as translation and scaling are concerned..

Then, it is the visualizer that recognizes what gets put together as a view-set, and calculates the translations and scalings that one view-set imposes on another view-set..

Take an example: Summation symbol..  the body is a separate view-set, but the summation view-set determines the scaling and position of the body set.  

   There needs to be some connection, from the transform that places the child, to the root view box of that child.  The child has its own root element, and that element has its own view set.  So, that view set should be attached as the contents of the child-position in the parent -- the root view box of the view set should be attached to the end of the chain of child's transforms in the parent.
   Do this connection inside the link object that links two view-sets.  The link states which is the parent, and it states a translation and scaling to be applied to the child view set.  The translation and scaling is relative to the parent's origin (which can, in turn be a child for some other view set, such that it was translated and scaled, and so on..)

====================
Implementation:
-] create a view-set object
-] two kinds of links in the view hierarchy.. 
- -] the view set acts as root/head to its contained viewboxes, which form a tree.
- -] the view set has array of objects that act as links to other view sets.  The link objects are shared by both view-sets, and back-link to the view sets.  

Hence, a view-set determines the relative positions and sizes of other view sets via the link objects.  each view set knows only about the link objects it is connected to.

-] view set link object has two pointers in it, one to the parent view-set and one to the child view-set.  A link object contains an offset and a scale, that are relative to the parent view-set's root viewbox, and are applied to the child view-set's whole view tree.



